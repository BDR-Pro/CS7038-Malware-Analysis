---
title: Simple Program Analysis with Immunity
author: Coleman Kane
twitter_image: 
tags:
 - malware
 - immunity debugger
 - disassembly
 - lecture
---

Now, we will perform some analysis on a few example binaries. These will help
to understand what situations many of the available tools are useful for that were
discussed in the previous section.

Install the "MingW" developmnent suite in your Kali VM to be able to
cross-compile Windows binaries on Linux:

```bash
apt install mingw-w64
```

Despite the name, this will install the 32-bit utilities, too, which is mainly what
we want. This gives us the ability to build new Windows executables from C and C++
code within the Kali environment.

If you recall, when we analyzed the "Revolution Backdoor" sample, there were only about
4-5 functions defined in the C++ code, but Ghidra displayed many functions to us.
Through analysis, we determined that the entry point of the program is not pointing
at the `main` function that was written into the source code, but rather to another
function which did some start-up work and eventually called our `main` function once
a number of additional "start up" work was completed.

# Writing a simplified EXE

Building a simplified EXE is helpful, as it allows us to analyze specific code without
having to navigate through all of the additional "standard library" code provided by
the compiler. We can write a function like the following, using the `WinMain` function
as our entry point, and have a simpler analysis project:

```c++
#include <windows.h>

int WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
        LPSTR lpszCmdLine, int nCmdShow) {
  MessageBoxA(NULL, "TEST", "TEST", MB_OK);
  return 1;
}
```

We also need to tell the compiler this is what we want, as it will not automatically
determine what we are trying to do here. Using the following command, with the above
code in `ex1.cpp`, we can compile a slimmed-down EXE:
```bash
i686-w64-mingw32-g++ -o ex1.exe -mconsole -nostdlib -s ex1.cpp -luser32
```

Looking at the file, we can see that it is only 2048 bytes, which is tiny:
```
-rwxr-xr-x 1 root root 2048 Feb 16 23:24 ex1.exe
```

If I left out the `-nostdlib` parameter, additional code will be added, making the
EXE grow to over 11kB in size.

# Analyzing our Simple EXE

The EXE that was built contains a single function, named `WinMain` in the source (but
the `-s` option will strip the symbols for us), which simply calls the `MessageBoxA`
function to display a dialog to the user, pausing program execution, until the user
clicks "OK". It then returns to Windows with a return value of `1`.

We can load this up in Immunity Debugger and we can easily make out the components of
the program from the source code, in the disassembly view:

![Immunity Debugger Looking at ex1.exe](/stuff/immdbg-ex1-exe.png)

As you can see, the only code displayed in the disassembly view (and, if you load it up
in Ghidra, the only code at all) is the disassembly for the `WinMain` function that was
provided above. The program is paused, and the first instruction to execute next is:

```asm
PUSH EBP
```

Looking at the code, our function call begins at line 4, where the value `0` is moved
onto the stack, representing the value that the `MB_OK` macro represents. It is worth
noting that, when arguments to functions are passed on the stack, they are typically
moved onto the stack in reverse order, from last to first (right to left).

Doing a step-into (F7) or step-over (F8) 8 times places the EIP and the cursor on the
`CALL EAX` line.

![Immunity Debugger on CALL EAX](/stuff/immdbg-ex1-calleax.png)

Immunity Debugger recognizes this as a function call to `MessageBoxA`
and updates the stack view and the CPU state's register view to reflect this. In the
stack view (lower right), you can now see the parameter names and which values they
correspond to have been noted by the debugger. You can even see that the `Style`
parameter was interpreted for us as `MB_OK|MB_APPLMODAL`, which was very handy. These
values are documented in the MSDN documentation and this informs us about how the dialog
will behave. This is a key benefit to Immunity Debugger - it contains a bunch of features
that will decode well-known parameter types in Windows for us.

![MessageBoxA Call Parameter Stack](/stuff/immdbg-ex1-msgboxa-callstack.png)

Doing a **step-over** (F8) at this point, will cause the dialog box to display. It may
pop up behind your debugger, so you might need to Alt+Tab to find it. You'll also notice
that the lower-right corner of the debugger window displays "**Running**" rather than
"**Paused**" now. This is because the code inside of the `MessageBoxA` function contains
a loop which will loop forever until the "OK" button is clicked. When we go ahead and
click this button, the program will get **Paused** again, but this time will be waiting
on the following line of code:

```asm
SUB ESP,10
```

Next, click the "Restart Program" button, which looks like the two arrows pointing left:
&lt;&lt;.

[home](/)
